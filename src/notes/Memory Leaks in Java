Memory Leaks in Java (Real-Time Use Case & Fixes)

âœ…ï¸Since Java has automatic garbage collection (GC), many developers assume memory leaks canâ€™t happen. But they do!
Java memory leaks occur when objects are no longer needed but are still unintentionally referenced, preventing GC from reclaiming memory

ğŸ“ŒCommon Causes of Memory Leaks in Java :

ğŸ’Static Collections (Maps, Lists, etc.)
Objects added to static collections are never removed.

ğŸ’Unclosed Resources (Files, DB connections, Streams).
ğŸ’Listeners & Callbacks Not Removed (Event listeners in Swing, Android, etc.).

ğŸ’ThreadLocal Variables Not Cleaned Up

ğŸŒ³Real-Time Use Case: Memory Leak in a Caching System :

ğŸŒ´Scenario :
A Java application caches user sessions in a static HashMap. Over time, unused sessions remain in memory, causing an OutOfMemoryError.
ğŸ‘‡
public class SessionCache {
 private static final Map<Long, UserSession> cache = new HashMap<>();

 public void addUserSession(Long userId, UserSession session) {
 cache.put(userId, session); // Stored forever unless manually removed!
 }

 public UserSession getSession(Long userId) {
 return cache.get(userId);
 }

ğŸŒ³Why is this a memory leak?

ğŸ”¹ï¸static Map lives for the entire application lifetime.

ğŸ”¹ï¸Even if a UserSession is no longer needed, it remains in cache.

ğŸ”¹ï¸Over time, this fills up heap memory, leading to OutOfMemoryError

âœ…ï¸ğŸŒ´Solution 1: Use WeakHashMap (Auto-Cleaning) :

public class SessionCache {
 // WeakHashMap allows GC to remove unused entries
 private static final Map<Long, UserSession> cache = new WeakHashMap<>();

 public void addUserSession(Long userId, UserSession session) {
 cache.put(userId, session);
 }

 public UserSession getSession(Long userId) {
 return cache.get(userId);
 }

âœ…ï¸WeakHashMap uses weak references, so if no other code references UserSession, GC can remove it.

âœ…ï¸Solution 2: Manual Cleanup (Best for Controlled Caching)

ğŸŒ³If you need strong control over cache eviction.

ğŸŒ³Call removeSession() when a user logs out or becomes inactive.

âŒï¸â“ï¸Another Real-World Example: Unclosed Resources

Problem (File Leak)

public void readFile(String path) {
 try {
 BufferedReader reader = new BufferedReader(new FileReader(path));

 String line = reader.readLine(); // What if an exception occurs?

 // ... process file ...
 // Missing: reader.close();
 } catch (IOException e) {
 e.printStackTrace();
 }
}

âŒï¸Why is this a leak?

ğŸŒ´If an exception occurs, reader is never closed â†’ file handle leak.

âœ…ï¸Fix: Use Try-With-Resources (Auto-Closing)

ğŸŒ³try-with-resources ensures close() is called even if an exception occurs

â“ï¸How to Detect Memory Leaks in Java?

ğŸ”¹ï¸VisualVM / Java Mission Control (Monitor heap usage).

ğŸ”¹ï¸Eclipse Memory Analyzer (MAT) (Analyze heap dumps).

ğŸ”¹ï¸-Xmx & -Xms flags (Set heap size to detect leaks early).

ğŸ”¹ï¸Profiling Tools (YourKit, JProfiler)


===============================================================================

Memory leaks in Spring Boot applications can lead to high memory usage, slow performance, and even OutOfMemoryErrors (OOM).

ğŸŸ£The â€œLeaky Tankâ€ Problem :

Imagine running a high-performance microservice that processes thousands of requests per second. Suddenly:

ğŸ“ŒIssues Start Appearing:

âŒï¸Increasing memory usage

âŒï¸Slower response times

âŒï¸Frequent garbage collection (GC) pauses

âŒï¸Eventuallyâ€¦ OOM Errors!

Think of your applicationâ€™s memory as a water tank. If thereâ€™s a leak, the tank keeps filling until it overflows.

ğŸŒ´To prevent crashes, we need to detect & fix these leaks before they happen!

ğŸŸ£What Causes Memory Leaks in Spring Boot?

ğŸ“ŒDetecting Memory Leaks: JVM Profiling Tools

ğŸ“ŒMonitor Memory Usage with Spring Boot Actuator

ğŸ“ŒProfile Memory Usage with VisualVM

ğŸŸ£Fixing Common Memory Leaks in Spring Boot : below are some steps we can take to prevent and fix the issue ğŸŸ£

âœ…ï¸Fix #1: Closing Database Connections Properly

âœ” Use try-with-resources to auto-close connections

âœ…ï¸Fix #2: Limiting Cache Growth

âœ” Use size-limited caches to prevent unbounded memory growth

âœ…ï¸Fix #3: Use Thread Pools Instead of Creating New Threads

âœ” Uses thread pools instead of creating infinite threads

âœ…ï¸Fix #4: Set Correct Bean Scope

âŒï¸Wrong (Singleton Beans hold memory forever)

âœ” Better Approach: Use Request Scope

âœ” Creates beans per request, reducing memory footprint

âœ…ï¸Fix #5: Close InputStreams to Avoid Leaks

âŒï¸Wrong: InputStream never closed

âœ” Better Approach: Use Try-with-Resources

âœ” Ensures InputStream is always closed

ğŸŸ£Best Practices for Memory Optimization in Production
âœ” Enable GC Logging for Monitoring

âœ” Set Maximum Heap Size for Containers

âœ” Use GraalVM Native Image for Low-Memory Execution