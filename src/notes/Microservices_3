Day 2 Scenario 2: Ensuring Idempotency in API Calls



1ï¸âƒ£Q)Your Order Service receives the same request multiple times due to network issues. How do you prevent duplicate order processing?

âœ…ï¸Solution:

ğŸ”¹ï¸Use an Idempotency Key sent by the client.

ğŸ”¹ï¸Store processed requests in Redis or a database to reject duplicates.

ğŸ’Example:
ğŸ‘‡
if (redis.exists(idempotencyKey)) {
 return "Duplicate request";
} else {
 redis.set(idempotencyKey, "processed", 5, TimeUnit.MINUTES);
 processOrder();
}

ğŸ”¹ Key Concepts: Idempotency Key, Deduplication, Redis, Database Locks.

ğŸŸ£Scenario 2: Managing Distributed Transactions (Without 2PC)

2ï¸âƒ£Q)An e-commerce system needs to manage transactions across Order, Payment, and Inventory services. How do you ensure consistency without using Two-Phase Commit (2PC)?

âœ…ï¸Solution:

ğŸ”¹ï¸Implement Saga Pattern (Choreography or Orchestration).

ğŸ”¹ï¸Choreography: Each service listens to events and reacts.

ğŸ”¹ï¸Orchestration: A central Saga Orchestrator ensures transaction flow.

ğŸ’Example:
ğŸ‘‡

@SagaStep
public void reserveInventory(SagaContext context) {
 if (inventoryAvailable(context.getOrderId())) {
 context.sendEvent("inventory_reserved");
 } else {
 context.sendEvent("inventory_failed");
 }
}

ğŸ”¹ Key Concepts: Saga Pattern, Event-Driven Architecture, Compensation Transactions.